#!/usr/bin/env python3
"""
Application usage tracker for Hyprland
Tracks active and passive usage time for all running applications
"""

import json
import sqlite3
import subprocess
import time
import re
from datetime import datetime
from pathlib import Path

# Configuration
DB_PATH = Path.home() / ".local/share/app-tracker/usage.db"
POLL_INTERVAL = 1.0  # seconds

def init_db():
    """Initialize SQLite database"""
    DB_PATH.parent.mkdir(parents=True, exist_ok=True)

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # Create sessions table with active/passive tracking
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS app_sessions_v2 (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            app_name TEXT NOT NULL,
            started_at TEXT NOT NULL,
            ended_at TEXT,
            active_seconds INTEGER DEFAULT 0,
            passive_seconds INTEGER DEFAULT 0
        )
    """)

    # Create metadata table for app information
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS app_metadata (
            app_name TEXT PRIMARY KEY,
            display_name TEXT,
            exec_command TEXT,
            icon TEXT,
            last_updated TEXT
        )
    """)

    conn.commit()
    conn.close()

def get_all_running_apps():
    """Get all running applications from Hyprland"""
    try:
        result = subprocess.run(
            ['hyprctl', 'clients', '-j'],
            capture_output=True,
            text=True,
            check=True
        )
        clients = json.loads(result.stdout)

        # Get unique app classes
        apps = set()
        for client in clients:
            app_class = client.get("class", "")
            if app_class and app_class != "":
                apps.add(app_class)

        return apps
    except (subprocess.CalledProcessError, json.JSONDecodeError, KeyError):
        return set()

def get_active_app():
    """Get currently active application from Hyprland"""
    try:
        result = subprocess.run(
            ['hyprctl', 'activewindow', '-j'],
            capture_output=True,
            text=True,
            check=True
        )
        data = json.loads(result.stdout)
        app_class = data.get("class", "")

        if not app_class or app_class == "":
            return None

        return app_class
    except (subprocess.CalledProcessError, json.JSONDecodeError, KeyError):
        return None

def find_desktop_file(app_name):
    """Find .desktop file for an application"""
    search_dirs = [
        Path.home() / ".local/share/applications",
        Path("/usr/share/applications"),
        Path("/usr/local/share/applications"),
    ]

    # Try exact match first
    for search_dir in search_dirs:
        if not search_dir.exists():
            continue

        # Try app_name.desktop
        desktop_file = search_dir / f"{app_name.lower()}.desktop"
        if desktop_file.exists():
            return desktop_file

        # Try searching for files containing the app name
        try:
            for file in search_dir.glob("*.desktop"):
                if app_name.lower() in file.stem.lower():
                    return file
        except (PermissionError, OSError):
            continue

    return None

def parse_desktop_file(desktop_file):
    """Parse .desktop file and extract Name, Exec, and Icon"""
    try:
        with open(desktop_file, 'r', encoding='utf-8') as f:
            content = f.read()

        # Extract Name, Exec, and Icon fields
        name_match = re.search(r'^Name=(.+)$', content, re.MULTILINE)
        exec_match = re.search(r'^Exec=(.+)$', content, re.MULTILINE)
        icon_match = re.search(r'^Icon=(.+)$', content, re.MULTILINE)

        name = name_match.group(1) if name_match else None
        exec_cmd = exec_match.group(1) if exec_match else None
        icon = icon_match.group(1) if icon_match else None

        # Clean up Exec command (remove %u, %f, etc.)
        if exec_cmd:
            exec_cmd = re.sub(r'%[uUfFdDnNickvm]', '', exec_cmd).strip()

        return name, exec_cmd, icon
    except (IOError, OSError):
        return None, None, None

def extract_web_app_metadata(app_name):
    """Extract metadata for Chrome web apps"""
    # Pattern: chrome-<domain>__<optional-path>-Default
    match = re.match(r'^chrome-([a-zA-Z0-9.-]+)__.*-Default$', app_name)
    if not match:
        return None, None, None

    domain = match.group(1)

    # Generate display name from domain
    if '.' in domain:
        # Extract main part before TLD
        parts = domain.split('.')
        if len(parts) >= 2:
            # Handle subdomains (app.hey.com -> Hey, web.whatsapp.com -> Whatsapp)
            if parts[0] in ['app', 'web', 'mail', 'drive', 'docs', 'photos', 'messages', 'calendar'] and len(parts) >= 3:
                display_name = parts[1].capitalize()
            else:
                display_name = parts[-2].capitalize()
        else:
            display_name = domain.capitalize()
    else:
        display_name = domain.capitalize()

    # Reconstruct URL for launching
    exec_cmd = f"omarchy-launch-webapp https://{domain}"

    # Try to get icon from domain
    icon = ""

    return display_name, exec_cmd, icon

def get_or_create_app_metadata(app_name):
    """Get app metadata from database or create it if it doesn't exist"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # Check if metadata already exists
    cursor.execute("SELECT display_name, exec_command, icon FROM app_metadata WHERE app_name = ?", (app_name,))
    row = cursor.fetchone()

    if row:
        conn.close()
        return  # Metadata already exists

    # Extract metadata
    display_name = None
    exec_cmd = None
    icon = None

    # Check if it's a web app
    if app_name.startswith('chrome-') and '-Default' in app_name:
        display_name, exec_cmd, icon = extract_web_app_metadata(app_name)

    # Try finding .desktop file
    if not display_name or not exec_cmd:
        desktop_file = find_desktop_file(app_name)
        if desktop_file:
            name, cmd, ic = parse_desktop_file(desktop_file)
            if not display_name:
                display_name = name
            if not exec_cmd:
                exec_cmd = cmd
            if not icon:
                icon = ic

    # Fallbacks
    if not display_name:
        display_name = app_name
    if not exec_cmd:
        exec_cmd = app_name
    if not icon:
        icon = ""

    # Store metadata
    cursor.execute("""
        INSERT OR REPLACE INTO app_metadata (app_name, display_name, exec_command, icon, last_updated)
        VALUES (?, ?, ?, ?, ?)
    """, (app_name, display_name, exec_cmd, icon, datetime.now().isoformat()))

    conn.commit()
    conn.close()

def start_session(app_name):
    """Start tracking a new app session"""
    # Ensure metadata exists for this app
    get_or_create_app_metadata(app_name)

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    started_at = datetime.now().isoformat()

    cursor.execute("""
        INSERT INTO app_sessions_v2 (app_name, started_at, active_seconds, passive_seconds)
        VALUES (?, ?, 0, 0)
    """, (app_name, started_at))

    session_id = cursor.lastrowid
    conn.commit()
    conn.close()

    return session_id

def end_session(session_id):
    """End an app session"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    ended_at = datetime.now().isoformat()

    cursor.execute("""
        UPDATE app_sessions_v2
        SET ended_at = ?
        WHERE id = ?
    """, (ended_at, session_id))

    conn.commit()
    conn.close()

def increment_active_time(session_id, seconds):
    """Add active time to a session"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        UPDATE app_sessions_v2
        SET active_seconds = active_seconds + ?
        WHERE id = ?
    """, (seconds, session_id))

    conn.commit()
    conn.close()

def increment_passive_time(session_id, seconds):
    """Add passive time to a session"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        UPDATE app_sessions_v2
        SET passive_seconds = passive_seconds + ?
        WHERE id = ?
    """, (seconds, session_id))

    conn.commit()
    conn.close()

def main():
    print("Starting app tracker with active/passive tracking...")
    init_db()
    print(f"Database: {DB_PATH}")
    print("Tracking all running applications...\n")

    # Track currently running apps: {app_name: session_id}
    running_sessions = {}
    was_screensaver_active = False

    try:
        while True:
            # Get current state
            current_running = get_all_running_apps()
            active_app = get_active_app()

            # Check if screensaver/lock screen is active
            is_screensaver = active_app and active_app.lower() in ['screensaver', 'hyprlock', 'swaylock']

            # Handle screensaver activation
            if is_screensaver and not was_screensaver_active:
                # Screensaver just activated - pause all sessions
                print(f"[{datetime.now().strftime('%H:%M:%S')}] Screen locked - pausing tracking")
                for app, session_id in running_sessions.items():
                    end_session(session_id)
                running_sessions.clear()
                was_screensaver_active = True

            # Handle screensaver deactivation
            elif not is_screensaver and was_screensaver_active:
                # Screensaver just deactivated - resume tracking
                print(f"[{datetime.now().strftime('%H:%M:%S')}] Screen unlocked - resuming tracking")
                was_screensaver_active = False

            # Skip all tracking while screensaver is active
            if is_screensaver:
                time.sleep(POLL_INTERVAL)
                continue

            # Normal tracking when not locked
            # Start sessions for new apps
            for app in current_running:
                if app not in running_sessions:
                    session_id = start_session(app)
                    running_sessions[app] = session_id
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Started: {app}")

            # End sessions for closed apps
            for app in list(running_sessions.keys()):
                if app not in current_running:
                    end_session(running_sessions[app])
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] Ended: {app}")
                    del running_sessions[app]

            # Update active/passive time for all running apps
            for app in current_running:
                session_id = running_sessions[app]
                if app == active_app:
                    increment_active_time(session_id, int(POLL_INTERVAL))
                else:
                    increment_passive_time(session_id, int(POLL_INTERVAL))

            time.sleep(POLL_INTERVAL)

    except KeyboardInterrupt:
        # Clean shutdown - close all sessions
        for app, session_id in running_sessions.items():
            end_session(session_id)
            print(f"[{datetime.now().strftime('%H:%M:%S')}] Ended: {app}")
        print("\nStopped app tracker")

if __name__ == "__main__":
    main()
